Сборка является базовой структурной единицей в .NET, на уровне которой проходит контроль версий, развертывание и конфигурация приложения.Сборки кристаллизуют всю библиотеку классов .NET - при написании кода и создании сборки своего приложения мы используем пространства имен, которые размещены в других сборках .NET. Сборки имеют следующие составляющие:манифест, который содержит метаданные сборки; метаданные типов. спользуя эти метаданные, сборка определяет местоположение типов в файле приложения, а также места размещения их в памяти; собственно код приложения на языке MSIL, в который компилируется код C# Все эти компоненты могут находиться в одном файле, и тогда сборка представляет один единственный файл в формате exe или dll.
Библиотека классов определяет типы и методы, которые могут быть вызваны из любого приложения. Библиотеку классов, предназначенную для .NET Standard 2.0, можно вызывать из любой реализации .NET, которая поддерживает эту версию .NET Standard. Когда вы завершите создание библиотеки классов, вы сможете по своему усмотрению распространять ее как независимый компонент или включить в состав одного или нескольких приложений.После того, как вы создали библиотеку классов .NET Standard, протестировали ее и построили окончательную версию, следующий шаг — сделать ее доступной для вызывающих объектов. Для этого существуют два способа: если вся библиотека будет использоваться в одном решении (например, она является компонентом крупного приложения), достаточно включить библиотеку в проект этого решения; если же библиотеку нужно сделать общедоступной, ее следует предоставлять как пакет NuGet.
Атрибуты в .NET представляют специальные инструменты, которые позволяют встраивать в сборку дополнительные метаданные. Атрибуты могут применяться как ко всему типу (классу, интерфейсу и т.д.), так и к отдельным его частям (методу, свойству и т.д.). Основу атрибутов составляет класс System.Attribute, от которого образованы все остальные классы атрибутов. В .NET имеется множество различных классов атрибутов. Например, при сериализации в различные форматы используются атрибуты [Serializable] и [NonSerialized]. С помощью рефлексии стандартные классы .NET получают использованные атрибуты и производят определенные действия. Например, атрибут [Serializable] указывает классу BinaryFormatter, что объекты с данным атрибутом можно сохранять в бинарный файл. В то ж время пока к классу с атрибутом не применена рефлексия, атрибут не размещается в памяти, и никакого влияния на данный класс не оказывает.Ограничение задает перечисление AttributeTargets, которое может принимать еще ряд значений: All: используется всеми типами; Assembly: атрибут применяется к сборке; Constructor: атрибут применяется к конструктору; Delegate: атрибут применяется к делегату; Enum: применяется к перечислению; Event: атрибут применяется к событию; Field: применяется к полю типа; Interface: атрибут применяется к интерфейсу; Method: применяется к методу; Property: применяется к свойству; Struct: применяется к структуре
Директивы препроцессора обычно используются для облегчения преобразования исходных программ и их легкой компиляции в разных средах исполнения. Директивы в исходном файле сообщают препроцессору выполнять определенные действия. Например, препроцессор может заменить токены в тексте, вставить содержимое других файлов в исходный файл или подавить компиляцию части файла, удалив разделы текста. Линии препроцессора распознаются и выполняются перед расширением макроса. Поэтому, если макрос расширяется во что-то, что выглядит как команда препроцессора, эта команда не распознается препроцессором. Операторы препроцессора используют тот же набор символов, что и для операторов исходного файла, за исключением того, что escape-последовательности не поддерживаются. Набор символов, используемый в инструкциях препроцессора, совпадает с набором символов выполнения. Препроцессор также распознает отрицательные значения символов. Список директив: #define [symbol] // Определяет символ компилятора. #undef [symbol] // Undefine символ компилятора. #warning [warning message] // Создает предупреждение компилятора. Полезно с #if. #error [сообщение об ошибке] // Создает ошибку компилятора. Полезно с #if. #line [номер строки] (имя файла) // Переопределяет номер строки компилятора (и, возможно, имя исходного файла). Используется с текстовыми шаблонами T4 . #pragma warning [disable | restore] [warning numbers] // Отключает / восстанавливает предупреждения компилятора. #pragma checksum " [filename] " " [guid] " " [checksum] " // Проверяет содержимое исходного файла. #region [имя региона] // Определяет область складного кода. #endregion // Заканчивает блок области кода. #if [condition] // Выполняет код ниже, если условие истинно. #else // Используется после #if. #elif [condition] // Используется после #if. #endif // Завершает условный блок, начинающийся с #if.